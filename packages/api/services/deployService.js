const fsp = require("fs").promises;
const path = require("path");
const common = require("@spaship/common");
const { log } = require("@spaship/common/lib/logging/pino");
const decompress = require("decompress");
const config = require("../config");
const fileService = require("./fileService");

/**
 * detect if the archive was created with `npm pack`.  npm pack creates a
 * tarball with a "package" dir.  we want what's in the package dir but not
 * the dir itself.
 * @param {*} dir
 */
const isNPMPack = async (dir) => {
  try {
    const packageStat = await fsp.lstat(path.join(dir, "package"));
    return packageStat.isDirectory();
  } catch (e) {
    log.error(e);
  }
  return false;
};

async function deploy({ name, spaArchive, appPath, ref } = {}) {
  // create a dir in the tmp_dir location, but keep the random archive name
  let tmpDir = `${spaArchive}-extracted`;
  await fsp.mkdir(tmpDir);

  // extract the archive
  await decompress(spaArchive, tmpDir);

  // if the archive was generated by `npm pack`, move into the "package"
  // directory where all the goodies are.
  const shouldRepath = await isNPMPack(tmpDir);
  if (shouldRepath) {
    tmpDir = path.join(tmpDir, "package");
  }

  let spaConfig = { name, path: appPath };
  let hasYaml = false;
  let incomingDeployKey;
  const yamlFilePath = path.join(tmpDir, "spaship.yaml");
  try {
    spaConfig = await common.config.read(yamlFilePath);
    incomingDeployKey = spaConfig.deploykey;
    hasYaml = true;
  } catch (e) {
    log.error(e);
  }

  const validation = common.config.validate(spaConfig);

  if (!validation.valid) {
    throw new Error(`spaship.yaml is not valid: ${JSON.stringify(validation.errors)}`);
  }

  // remove starting slashes in paths
  const flatPath = common.flatpath.toDir(spaConfig.path);
  const destDir = path.join(config.get("webroot"), flatPath);

  // write spa metadata to filesystem
  if (!hasYaml) {
    fileService.write(path.join(tmpDir, "spaship.yaml"), {
      name,
      path: spaConfig.path,
    });
  }
  if (ref) {
    fileService.write(path.join(tmpDir, "spaship.yaml"), {
      ref,
    });
  }

  let existingDeployKey;
  try {
    const existingConfig = await common.config.read(path.join(destDir, "spaship.yaml"));
    existingDeployKey = existingConfig.deploykey;
  } catch (e) {}

  const noDeployKey = typeof existingDeployKey === "undefined";

  // if the deployment doesn't have a deploykey, add one
  if (noDeployKey && !incomingDeployKey) {
    const deploykey = common.config.deploykey.generate();
    fileService.write(yamlFilePath, {
      deploykey,
    });
  }

  // write htaccess file
  await common.htaccess.write(tmpDir, spaConfig);

  // @kyan : I remove following lines because we don't deployKey in yaml any more
  // // deploy if:
  // //   no existing deploy key, or
  // //   existing deploy key and incoming key matches
  // const deployKeysValid = typeof existingDeployKey === "string" && typeof incomingDeployKey === "string";
  // const deployKeysMatch = existingDeployKey === incomingDeployKey;
  // if (noDeployKey || (deployKeysValid && deployKeysMatch)) {
  //   await fsp.rename(tmpDir, destDir);
  // } else {
  //   throw new Error(`${name}'s deploykey does not match. Incoming deploy key: "${incomingDeployKey}"`);
  // }

  try {
    await fsp.rename(tmpDir, destDir);
  } catch (error) {
    log.error(error);
  }
}

module.exports = { deploy };
